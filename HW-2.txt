1)
 1-A system to control antilock braking in a car 
   -Safety Critical System 
   -Plan Driven approach with requirements analysed carefully 
   -Waterfall model most appropriate with formal transformations between different development stages. 

 2-A virtual reality system to support software maintenance 
   -Cutting edge and UI dependent for usability 
   -Incremental or Spiral with some UI prototyping 
   -Agile process may be used 

 3-A university accounting system that replaces an existing system 
   -Requirements fairly well known 
   -Reuse based approach is appropriate 

 4-An interactive travel planning system that helps users plan journeys with the lowest environmental impact 
   -Complex UI which is stable and reliable 
   -Incremental development approach most appropriate 
   -System requirements will change as user experience is gained


2)
   1-Based on the idea of developing initial implementation, getting user feedback and evolving software through several versions. 
   
   2-Either plan driven, agile or mixture. 
   
   3-Customer can evaluate systems at a relatively early stage


3)
   1-Firstly requirements spec involve proposing initial requirements for the system  
     -Brief descriptions 

   2-Refinement stage, reusable components and applications discovered for refinement. 
     -Modified to reflect available components and system spec is redefined.


4)
  1-User Requirements describe the system functions and features from the perspective of a user. These are usually abstract.
   System requirements provide a more detailed explanation of the procedure. 
 
  3-User requirements are written in plain and natural language. System requirements are more detailed 
    with specific specifications that could be part of a contract. 
 
  4-User requirements start with gathering information, identifying important aspects, and understanding them. 
    System Requirements can only be implemented after the user requirements are understood and finalised. 


5)
  Design of architecture: 
   -System overall structure is defined. 
   -Discuss reason for interdependency 
 
  Design of Database: 
   -Define structure of database as representation. 
 
  Design of interface: 
   -Interface defined here. 
   -Ease of use 
 
  Component design and selection 
   -Reusable components matching requirements are defined here 
 

6)
 Software testing: 
   -Each program is tested for correct functionality 
   -Complete program divided into small modules, tested individually. (UNIT TESTING) 
   -Then whole system is tested with the programs tested above. (SYSTEM TESTING) 
   -Beta version released and end user checks (CUSTOMER TESTING) 
 
 Programmers are not the best persons 
   -Hard to find own errors. 
   -Best skills to develop but not to test. 
 

7)
 Pros: 
   -Allows changes to prototype 
   -Customer sees prototype and modifications made before design is created 
   -Better implementation 
   -Satisfied customer 
 
 Cons: 
   -Additional cost for prototype creation 
   -Delays due to extra time creating prototypes


8)
   -Prototype anticipates changes required
   -Requirements engineering prototype helps with elicitation and validation  
   -System design process: used to explore software solutions in UI development 
   -Minimal UI and not intuitive 
   -No error detection 
   -Vague error messages 
   -Not viewed as high quality product, only development aids.


9)
 Adv: 
   -Focused on software engineering processes and practices used 
   -Led to significant improvements in capabilities 
 
 Disadv: 
   -Too much overhead in formal process improvement in small companies 
   -Maturity estimation with agile processes is difficult


10)
   -Reduce human error in code creation 
   -Potential to produce similar or better software than conventionally produced software 
   -Cost reduction 
   -Standardised components used, increasing software reliability and cost reduction in future maintenance 
   -Automation assists software to address primary issues in the development process. (complexity, reliability, and productivity)